#책을 읽던 중에 간단한 그리디 문제를 봤다. 거스름 문제였는데 여기서 순서대로 나누기만 하면 되는 이유가 각자의 배수이기 때문이라고 했다.
#그렇다면 배수가 아닌 경우에 대해서는 어떤 풀이를 해야할까 고민했고 스스로 해본 방법이다.

#아래는 배열의 최소공배수를 구하는 함수다. 필요한 이유는 아래 적었다.
    
def gcd(a, b):
    while b != 0:
        r = a % b
        a = b
        b = r
    return a

#a = 거스를 돈, b = 거스름 코인 개수, coins = 거스름 코인 단위들

a = int(input())
coins = list(map(int, input().split()))
print(coins)
count = 0

#내가 한 생각은 코인의 개수가 많지 않다면 예외에 대한 코인들을 미리 만들어 처리할 수 있다는 생각이었다.
#그 예외의 최대는 최소공약수까지일 것이다.
#coins = [[2000, 4], [1600, 4], [1500, 3], [1200, 3], [800, 2], [500, 1], [400, 1], [100, 1]]
#이런 배열로 만들어줄 코드가 필요했다.
#거스름 문제라면 마지막 코인은 최소단위일것이므로 고려하지 않는다.

lcm = coins[0]
for i in coins[1:-1]:
    lcm = i * lcm / gcd(lcm, i)
print(lcm)

#코인들의 최소공배수를 찾았다.

d = dict()

d[coins[-1]] = 1
for i in coins[0:-1]:
    n = 2
    while i * n <= lcm and i * n <= a:
        if i * n not in d:
            d[i * n] = n
        else:
            break
    d[i] = 1
    print(d)
        
#그리고 그 수 전까지 예외처리 할 코인들을 새로 만들어줬다. 형태는 [가격, 코인수] 이다.
#큰 수부터 만들어가기 때문에 i * n 즉 배수가 되는 코인이 이미 d에 있다면 더 큰 코인수로 만들어줄 필요는 없다.

d = list(zip(d.keys(), d.values()))
d.sort(reverse = True)

#이제 d를 가지고 똑같은 그리디 문제를 풀듯이 하면 된다.

for i in d:
    count += (a // i[0]) * i[1]
    a = a % i[0]
    
print(count)
